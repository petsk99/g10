<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta charset="UTF-8"/>
<title>Jump save humanity</title>
<link rel="shortcut icon" type="image/x-icon" href="img/player_s.gif" />
<style>

body {
  margin: 0;
}

canvas {
    border:1px solid #d3d3d3;
    /*background-color: #DD0802;*/
}
/* Fjerner muligheten til å scolle på siden så canvasen dekker hele */
html, body {margin: 0; height: 100%; overflow: hidden}
</style>
</head>
<body onload="startGame()">
<script>

//Spilleren
var myGamePiece;
//Blokkene den lander på
var myObstacles = [];
//Scoren
var myScore;

var jumpSound;

var deadFacts = [
  "Gjennomsnittlig dyrelivbestand har sunket med 60 prosent på drøyt 40 år",
  "Det er mer karbondioksid i atmosfæren vår nå enn noen gang i menneskets historie",
  "To tredjedeler av ekstremværhendelser de siste 20 årene har vært påvirket av mennesker",
  "120 000 kvadratkilometer tropisk skog gikk tapt i 2018"
];

var restart = false;

//Parameterne er: omTrykket, venstre | hvis den ikke går venstre går den høyre
var touch = [false, false];

function startGame() {
    //Lager figuren og plasserer han i midten lavt nede
    myGamePiece = new component(30, 60, "img/player_s.gif", window.innerWidth/2-15, window.innerHeight-280, "image");

    jumpSound = new sound("sounds/jump.wav", 0.4);

    //Start blokken som han starter oppå
    //Å Gjøre endre størrelse utifra skjermstørrelse
    myObstacles.push(new component(window.innerWidth, 40, "img/start.gif", 0, window.innerHeight-40, "image"));

    //Starter med nok blokker
    var startBlokker = Math.floor(Math.random()*4+3);
    var oldH = window.innerHeight-20;
    var pleased = false;
    while(!pleased){
      for(var b = 0; b < startBlokker; b++){
        //Må lage fra bunnen av skjermen og oppover for at det ikke skal bli buggs med blokken den lander på og få skjermen opp
        //Parameterne fra bPos er x, y
        var bPos = calculateBlock(true);
        //alert(bPos);
        myObstacles.push(new component(100, 20, "img/block.gif", bPos[0], bPos[1], "image"));
      }
      //Denne passer på at hele skjermen blir fylt
      if(myObstacles[myObstacles.length-1].y > 150){
        pleased = false;
        startBlokker = 1;
      } else {
        pleased = true;
      }
    }



    //Setter gravitasjonen i spiller med hvor for han "Går ned"
    myGamePiece.gravity = 0.5;
    //Viser scoren
    myScore = new component("30px", "Consolas", "", 20, 40, "text");
    //Starter spiller, hvis vi kjører denne hver gang blir spillet raskere og raskere vi ønsker en konstant fart
    if(!restart)
      myGameArea.start();
}
//Er en object
var myGameArea = {
    //Lager hvis spillet skjer
    canvas : document.createElement("canvas"),

    start : function() {
      //Å Gjøre Få den til å oppdatere canvas størrelsen når man endrer på skjerm størrelsen
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.score = 0;
        this.interval = setInterval(updateGameArea, 20);

        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
         window.addEventListener("touchstart", touchstart);
         window.addEventListener("toucmove", touchmove);
         window.addEventListener("touchend", touchend);
       } else {
         console.log("PC");
       }
        //Ser hvilke knapper som blir tastet
        window.addEventListener('keydown', function (e) {
            myGameArea.key = e.keyCode;
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.key = false;
        })
        },

    clear : function() {
        //Fjerner alle tingene på skjermen, også blir de tegnet på nytt
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, src, x, y, type) {
    this.type = type;
    if(this.type == "image"){
      this.image = new Image();
      this.image.src = src;
    }
    this.score = 0;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
    this.heightChange = 0;
    this.gravity = 0;
    this.onBlock = 0;
    this.update = function() {
        ctx = myGameArea.context;
        if (this.type == "text") {
            ctx.font = this.width + " " + this.height;
            ctx.fillStyle = 'black';
            ctx.fillText(this.text, this.x, this.y);
        } else if(type == "image"){
          ctx.drawImage(this.image,
          this.x,
          this.y,
          this.width, this.height);
        } else {
            ctx.fillStyle = src;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    this.newPos = function() {
        this.speedY += this.gravity;
          //Får hvilke tast det er fra https://keycode.info/
        //Å gjøre: Få farten til å være relativ til størrelsen på skjermen

        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
          if(touch[0] && touch[1]){
            //alert("venstre");
            this.speedX = -7; myGamePiece.image.src="img/player_l.gif";
          } else if(touch[0] && !touch[1]){
            //alert("høyre");
            this.speedX = 7; myGamePiece.image.src="img/player_r.gif";
          } else {
            this.speedX = 0;myGamePiece.image.src="img/player_s.gif";
          }
        } else {
          if ((myGameArea.key && myGameArea.key == 37)) {this.speedX = -7; myGamePiece.image.src="img/player_l.gif";} /* Bevger seg til VENSTRE */
          else if ((myGameArea.key && myGameArea.key == 39)) {this.speedX = 7; myGamePiece.image.src="img/player_r.gif";} /* Beveger seg til HØYRE */
          else {this.speedX = 0; myGamePiece.image.src="img/player_s.gif";} /* Hvis ingen av tastene blir trykt står den stille */
        }
        this.x += this.speedX;
        this.y += this.speedY;
        this.hitBottom();
        this.hitRight();
        this.hitLeft();
    }
    //Når den treffer høyre side
    this.hitRight = function(){
      var rightSide = myGameArea.canvas.width - this.width;
      if(this.x > rightSide){
        //alert("Right");
        this.speedX = 0;
        this.x = rightSide;
      }
    }
    //Når den treffer venstre side
    this.hitLeft = function(){
      var leftSide = 0;
      if(this.x < leftSide){
        this.speedX = 0;
        this.x = leftSide;
      }
    }
    //Når den treffer bakken
    this.hitBottom = function() {
        var rockbottom = myGameArea.canvas.height - this.height;
        if (this.y > rockbottom) {
            //De traff bunnen så de har tapt
            /*if(document.cookie != ""){
              var newHigh = checkHighscore();
              if(newHigh[0]){
                alert("Ny highscore: " + myScore.score+"\n"+deadFacts[Math.floor(Math.random()*deadFacts.length)]);
              } else {
                alert("Din score ble: " + myScore.score+"\nHighscoren er på: "+newHigh[1]+"\n"+deadFacts[Math.floor(Math.random()*deadFacts.length)]);
              }
            } else {*/
              alert("Din score ble: " + myScore.score+"\n Viste du at: "+deadFacts[Math.floor(Math.random()*deadFacts.length)]);
              /*document.cookie = "highscore="+myScore.score;
            }*/


            //alert("dead");
            this.y = rockbottom;
            this.speedY = 0;
            this.speedX = 0;

            restartGame();
        }
    }
    this.crashWith = function(otherobj) {

        var pRigth = otherobj.x + (otherobj.width);
        var pLeft = otherobj.x;
        var pTop = otherobj.y;
        var pBottom = otherobj.y + (otherobj.height);
        //this er spilleren
        var cRight = this.x + (this.width);
        var cLeft = this.x;
        var cBottom = this.y + (this.height);
        //Har ikke med chacter sitt hode så cTop er ikke med. Ettersom at vi ønsker at han kun kan hoppe med benene sine
        var crash = false;

        if(((pLeft < cRight) && (pRigth > cLeft) && (pBottom > cBottom) && (pTop < cBottom))){
          crash = true;
        }

        return crash;

    }
}

function updateGameArea() {
    var x, y, height, gap, minWidth, maxWidth;
    for (i = 0; i < myObstacles.length; i += 1) {
        //Ser om spilleren har krasjet i objektet
        if (myGamePiece.crashWith(myObstacles[i])) {
          //Gjør slik at figuren ikke "flyr" opp, men må lande på platformen først. Finnes det en bedre måte?

          //Ser at spilleren faller også blir det bedre flyt i spillet hvis det er 0.5
          if(myGamePiece.speedY > 0.5){

            if(myGamePiece.onBlock < i){
              //alert("ny blokk");
              var heightGap = myObstacles[myGamePiece.onBlock].y - myObstacles[i].y;

              myScore.score += heightGap;

              //Lager nye blokker, lager mellom 1 og 4? nye blokker
              var newBlocks = 1;
              //Kan endre størrelsen på blokkene
              for(var b = 0; b < newBlocks; b++){
                //Må lage fra bunnen av skjermen og oppover for at det ikke skal bli buggs med blokken den lander på og få skjermen opp
                var bPos = calculateBlock(false);
                //alert(bPos);
                myObstacles.push(new component(100, 20, "img/block.gif", bPos[0], bPos[1], "image"));
              }

              //For å passe på at skjermen alltid er full
              var fullScreen = false;
              while(!fullScreen){
                if(myObstacles[myObstacles.length-1].y > -50){
                  var bPos = calculateBlock(false);
                  console.log("ikke fullskjerm");
                  myObstacles.push(new component(100, 20, "img/block.gif", bPos[0], bPos[1], "image"));
                } else {
                  fullScreen = true;
                }
              }

              //Flytter alle blokkene ned med høydeforskjellen mellom gamle og nye blokken
              for(blokk of myObstacles){
                platformAnimation(blokk, heightGap);
                //blokk.y += heightGap;
                //Skrur ned farten hans så han ikke flyr opp når alle andre beveger seg ned Finnes det en bedre måte?
              }
              //myGamePiece.y += heightGap - 30;

              myGamePiece.onBlock = i;
            }
            jumpSound.play();
            myGamePiece.speedY = -13.2;

          }
        }
    }
    myGameArea.clear();
    myGameArea.frameNo += 1;
    for (i = 0; i < myObstacles.length; i += 1) {
        //Flytter objektet
        //myObstacles[i].y += 1;
        myObstacles[i].update();
    }
    myScore.text="SCORE: " + myScore.score;
    myScore.update();
    myGamePiece.newPos();
    myGamePiece.update();
}

function everyinterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}

function calculateBlock(start){
  var pos = [0,0];

  var highestBlock = myObstacles[myObstacles.length - 1];

  var validPos = false;
  //For å se om det er mulig å lande på den og at den er på banen
  do{

    //Tilfeldig enn så lenge
    var posX = Math.floor(Math.random() * window.innerWidth);



    //alert(window.innerWidth);
    var posY = highestBlock.y - Math.floor(Math.random() * 90 + 30);
    //Spilleren hopper 165 px oppover, regne ut det?
    //Hopper 375px til siden
    /*console.log("S.x: " + myGamePiece.x + " S.y: " + (window.innerHeight-40) + " S.x + 375: " + (myGamePiece.x + 375) + " S.y: " + (window.innerHeight-40) +
    " S.x: " + myGamePiece.x + " S.y - 165: " + (window.innerHeight-40-165));
    console.log(posX + " " + posY);*/
    /*
    if(isInside(myGamePiece.x,(window.innerHeight-40),(myGamePiece.x+375),(window.innerHeight-40),myGamePiece.x,(window.innerHeight-40-165),posX,posY) ||
      isInside(myGamePiece.x,(window.innerHeight-40),(myGamePiece.x-375),(window.innerHeight-40),myGamePiece.x,(window.innerHeight-40-165),posX,posY)){
          console.log("true");
          validPos = true;
    } else {
      posX = Math.floor(Math.random() * window.innerWidth + 50);
      posY = highestBlock.y - Math.floor(Math.random() * 90 + 5);
    }*/

    //Fungerer helt ok
    if((isInside(highestBlock.x,(highestBlock.y),(highestBlock.x+375),(highestBlock.y),highestBlock.x,(highestBlock.y-165),posX,posY) ||
      isInside(highestBlock.x,(highestBlock.y),(highestBlock.x-375),(highestBlock.y),highestBlock.x,(highestBlock.y-165),posX,posY)) &&
      posY + 165 > highestBlock.y){
          validPos = true;
    } else {
      do{
        var posX = Math.floor(Math.random() * window.innerWidth);
      } while (posX + 50 < highestBlock.x + 50 && posX > highestBlock.x - 50);
      posY = highestBlock.y - Math.floor(Math.random() * 90 + 30);

    }
  }while(!validPos);






  pos = [posX, posY];
  /*var pos = [0, 0];
  //alert("Making block");
  //Må finne forrige block og gi ny y verdi som er lavere enn forrige og bruke pytagoras for å se om det er mulig
  var lastBlock = myObstacles[myObstacles.length - 1];

    //Hopper vanligvis 235 pixler opp også kan han hoppe 300 px sidelengs
    //Å Gjøre Bedre måte å finne ut dette på
    //Brukes pytagoras a^2 = b^2 + c^2 for å ikke ta den nye blokken for langt til siden
  var maxToSide = Math.sqrt(300*300-235*235);
  var xToSide = Math.floor(Math.random()*maxToSide) + 50;
  var plussOrMinus = Math.floor(Math.random()*2);
  if(plussOrMinus == 1){
    xToSide = -xToSide;
  }
  var blockXPos = lastBlock.x + xToSide;
  //Første blokken har x = 0 så må rette det opp sånn
  if(myObstacles.length == 1){
    blockXPos = window.innerWidth/2 + xToSide;
  }
//Å gjøre ikke gå for langt ut på sidene utenfor bildet

  if(start){
    // -10 Gjør slik den nye blokken ikke blir lagd oppå den gamle
    var blockYPos = lastBlock.y - 10 - Math.floor(Math.random() * 150);
  }
  //Å Gjøre bedre måte å gjøre det på
  else {
    var blockYPos = lastBlock.y - 10 - Math.floor(Math.random() * 100);
  }
  //alert(blockYPos);
  pos = [blockXPos, blockYPos];
  return pos;*/
  return pos;
}

// vil respektivt være spiller.x, spiller.y, spiller.x, spiller.y + 165, spiller.x + 365, spiller.y, punkt.x, punkt.y
function isInside(x1,y1,x2,y2,x3,y3,x,y){
  var A = area(x1,y1,x2,y2,x3,y3);
  var A1 = area(x,y,x2,y2,x3,y3);
  var A2 = area(x1,y1,x,y,x3,y3);
  var A3 = area(x1,y1,x2,y2,x,y);
  //console.log("A: " + A + " A1: " + A1 + " A2: " + A2 + " A3: " + A3);
  return(A == A1 + A2 + A3);
}
//https://www.geeksforgeeks.org/check-whether-a-given-point-lies-inside-a-triangle-or-not/
function area(x1,y1,x2,y2,x3,y3){
  return Math.abs((x1*(y2-y3) + x2*(y3-y1)+x3*(y1-y2))/2.0);
}

function platformAnimation(platform, heightGap){
  var heightChange = 0;
  var id = setInterval(frame, 10);
  function frame(){
    if(heightChange >= heightGap){
      clearInterval(id);
    } else {
      platform.y += 2;
      heightChange += 2;
    }
  }
}

function sound(src, volume){
  this.sound = document.createElement("audio");
  this.sound.src = src;
  this.sound.setAttribute("preload", "auto");
  this.sound.setAttribute("controls", "none");
  this.sound.volume = volume/100;
  this.sound.style.display = "none";
  document.body.appendChild(this.sound);
  this.play = function(){
    this.sound.play();
  }
  this.stop = function(){
    this.sound.pause();
  }
}

function restartGame(){
  myGamePiece = [];
  myObstacles = [];
  myScore = [];
  restart = true;
  startGame();
}

function checkHighscore(){
  var returnScore = myScore.score;
  var newHigh = true;
  var highscore = getCookie("highscore");
  alert(document.cookie);
  if(highscore != ""){
    var cookieScore = parseInt(highscore);
    if(cookieScore > returnScore){
      newHigh = false;
      returnScore = cookieScore;
    }
  }
  if(newHigh){
    document.cookie = "highscore="+returnScore+";";
  }
  return [newHigh, returnScore];
}

function touchstart(evt){
  //Ser om trykket er på høyre side av skjermen
  if(evt.touches[0].clientX > window.innerWidth/2){
    touch = [true, false];
  } else if (evt.touches[0].clientX < window.innerWidth/2){
    touch = [true, true];
  }
}

function touchmove(evt){
  if(evt.touches[0].clientX > window.innerWidth/2){
    touch = [true, false];
  } else if (evt.touches[0].clientX < window.innerWidth/2){
    touch = [true, true];
  }
}

function touchend(evt){
  touch = [false, false];
}

//Brukes til debugging
function printMousePos(event) {

  if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {

  } else {
    alert("clientX: " + event.clientX +
      " - clientY: " + event.clientY);
  }
}

document.addEventListener("click", printMousePos);

</script>
<br>
</body>
</html>
