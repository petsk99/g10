<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Jump save humanity</title>
<style>

body {
  margin: 0;
}

canvas {
    border:1px solid #d3d3d3;
    background-color: #DD0802;
}
/* Fjerner muligheten til å scolle på siden så canvasen dekker hele */
html, body {margin: 0; height: 100%; overflow: hidden}
</style>
</head>
<body onload="startGame()">
<script>

/*
Ting å fikse:
Starte med tilfeldig antall blokker
Ikke lage ny blokk hvert 1,5 sek, men når han går opp
Lage algoritme slik at det alltid skal være mulig å lande på en blokk
Ikke kunne gå ut av banen
Passe på at de nye blokkene blir lagd og finnes

Kan lande på ny platform med hodet

Ser dum ut når han har landet på en ny platform

*/

//Spilleren
var myGamePiece;
//Blokkene den lander på
var myObstacles = [];
//Scoren
var myScore;

function startGame() {
    //Lager figuren og plasserer han i midten lavt nede
    myGamePiece = new component(30, 60, "img/player_s.gif", window.innerWidth/2-15, window.innerHeight-280, "image");
    //Start blokken som han starter oppå
    //Å Gjøre endre størrelse utifra skjermstørrelse
    myObstacles.push(new component(window.innerWidth, 40, "img/start.gif", 0, window.innerHeight-40, "image"));

    //Starter med nok blokker
    var startBlokker = Math.floor(Math.random()*10+3);
    var oldH = window.innerHeight-20;
    var pleased = false;
    while(!pleased){
      for(var b = 0; b < startBlokker; b++){
        //Må lage fra bunnen av skjermen og oppover for at det ikke skal bli buggs med blokken den lander på og få skjermen opp
        var bPos = calculateBlock(true);
        //alert(bPos);
        myObstacles.push(new component(100, 20, "img/block.gif", bPos[0], bPos[1], "image"));
      }
      //Denne passer på at hele skjermen blir fylt
      if(myObstacles[myObstacles.length-1].y > 150){
        pleased = false;
        startBlokker = 1;
      } else {
        pleased = true;
      }
    }


    //Setter gravitasjonen i spiller med hvor for han "Går ned"
    myGamePiece.gravity = 0.5;
    //Viser scoren
    myScore = new component("30px", "Consolas", "", 280, 40, "text");
    //Starter spiller
    myGameArea.start();
}
//Er en object
var myGameArea = {
    //Lager hvis spillet skjer
    canvas : document.createElement("canvas"),

    start : function() {
      //Å Gjøre Få den til å oppdatere canvas størrelsen når man endrer på skjerm størrelsen
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.score = 0;
        this.interval = setInterval(updateGameArea, 20);
        //Ser hvilke knapper som blir tastet
        window.addEventListener('keydown', function (e) {
            myGameArea.key = e.keyCode;
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.key = false;
        })
        },

    clear : function() {
        //Fjerner alle tingene på skjermen, også blir de tegnet på nytt
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, src, x, y, type) {
    this.type = type;
    if(this.type == "image"){
      this.image = new Image();
      this.image.src = src;
    }
    this.score = 0;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
    this.gravity = 0;
    this.onBlock = 0;
    this.update = function() {
        ctx = myGameArea.context;
        if (this.type == "text") {
            ctx.font = this.width + " " + this.height;
            ctx.fillStyle = 'black';
            ctx.fillText(this.text, this.x, this.y);
        } else if(type == "image"){
          ctx.drawImage(this.image,
          this.x,
          this.y,
          this.width, this.height);
        } else {
            ctx.fillStyle = src;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    this.newPos = function() {
        this.speedY += this.gravity;
          //Får hvilke tast det er fra https://keycode.info/
        //Å gjøre: Få farten til å være relativ til størrelsen på skjermen

        if (myGameArea.key && myGameArea.key == 37) {this.speedX = -7; myGamePiece.image.src="img/player_l.gif";} /* Bevger seg til VENSTRE */
        else if (myGameArea.key && myGameArea.key == 39) {this.speedX = 7; myGamePiece.image.src="img/player_r.gif";} /* Beveger seg til HØYRE */
        else {this.speedX = 0; myGamePiece.image.src="img/player_s.gif";} /* Hvis ingen av tastene blir trykt står den stille */
        this.x += this.speedX;
        this.y += this.speedY;
        this.hitBottom();
        this.hitRight();
        this.hitLeft();
    }
    //Når den treffer høyre side
    this.hitRight = function(){
      var rightSide = myGameArea.canvas.width - this.width;
      if(this.x > rightSide){
        //alert("Right");
        this.speedX = 0;
        this.x = rightSide;
      }
    }
    //Når den treffer venstre side
    this.hitLeft = function(){
      var leftSide = 0;
      if(this.x < leftSide){
        this.speedX = 0;
        this.x = leftSide;
      }
    }
    //Når den treffer bakken
    this.hitBottom = function() {
        var rockbottom = myGameArea.canvas.height - this.height;
        if (this.y > rockbottom) {
            //De traff bunnen så de har tapt

            //alert("dead");
            this.y = rockbottom;
            this.speedY = 0;
            this.speedX = 0;
        }
    }
    this.crashWith = function(otherobj) {

        var pRigth = otherobj.x + (otherobj.width);
        var pLeft = otherobj.x;
        var pTop = otherobj.y;
        var pBottom = otherobj.y + (otherobj.height);
        //this er spilleren
        var cRight = this.x + (this.width);
        var cLeft = this.x;
        var cBottom = this.y + (this.height);
        //Har ikke med chacter sitt hode så cTop er ikke med. Ettersom at vi ønsker at han kun kan hoppe med benene sine
        var crash = false;

        if(((pLeft < cRight) && (pRigth > cLeft) && (pBottom > cBottom) && (pTop < cBottom))){
          crash = true;
        }

        return crash;

    }
}

function updateGameArea() {
    var x, y, height, gap, minWidth, maxWidth;
    for (i = 0; i < myObstacles.length; i += 1) {
        //Ser om spilleren har krasjet i objektet
        if (myGamePiece.crashWith(myObstacles[i])) {
          //Gjør slik at figuren ikke "flyr" opp, men må lande på platformen først. Finnes det en bedre måte?


          if(myGamePiece.speedY > 0){

            if(myGamePiece.onBlock < i){
              //alert("ny blokk");
              var heightGap = myObstacles[myGamePiece.onBlock].y - myObstacles[i].y;

              myScore.score += heightGap * 10;

              //Lager nye blokker, lager mellom 1 og 4? nye blokker
              var newBlocks = Math.floor(Math.random()*3)+1;
              //Kan endre størrelsen på blokkene
              for(var b = 0; b < newBlocks; b++){
                //Må lage fra bunnen av skjermen og oppover for at det ikke skal bli buggs med blokken den lander på og få skjermen opp
                var bPos = calculateBlock(false);
                //alert(bPos);
                myObstacles.push(new component(100, 20, "img/block.gif", bPos[0], bPos[1], "image"));
              }

              //Flytter alle blokkene ned med høydeforskjellen mellom gamle og nye blokken
              for(blokk of myObstacles){
                blokk.y += heightGap;
                //Skrur ned farten hans så han ikke flyr opp når alle andre beveger seg ned Finnes det en bedre måte?
              }
              myGamePiece.y += heightGap - 30;

              myGamePiece.onBlock = i;
            }
            myGamePiece.speedY = -13.2;

          }
        }
    }
    myGameArea.clear();
    myGameArea.frameNo += 1;
    //Å gjøre kommer færre jo lenger du har kommet (Bruke score?)
    //Å Gjøre må skje når de når en ny platform / når skjermen går oppover
    //Hvor ofte det blir lagd en platform
    /*if (myGameArea.frameNo == 1 || everyinterval(150)) {
        //Å Gjøre skal være 0 også gå nedover når man hopper
        y = 20;
        x = Math.floor(Math.random()*myGameArea.canvas.width);
        minWidth = 50;
        maxWidth = 150;
        width = Math.floor(Math.random()*(maxWidth-minWidth+1)+minWidth);
        minGap = 50;
        maxGap = 200;
        gap = Math.floor(Math.random()*(maxGap-minGap+1)+minGap);
        //Lager blokkene
        myObstacles.push(new component(width, 20, "img/block.gif", x, y, "image"));
    }*/
    for (i = 0; i < myObstacles.length; i += 1) {
        //Flytter objektet
        //myObstacles[i].y += 1;
        myObstacles[i].update();
    }
    myScore.text="SCORE: " + myScore.score;
    myScore.update();
    myGamePiece.newPos();
    myGamePiece.update();
}

function everyinterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}

//Legge til parameter med hvor mange som skal bli lagd?
function calculateBlock(start){
  var pos = [0, 0];
  //alert("Making block");
  //Må finne forrige block og gi ny y verdi som er lavere enn forrige og bruke pytagoras for å se om det er mulig
  var lastBlock = myObstacles[myObstacles.length - 1];

    //Hopper vanligvis 235 pixler opp også kan han hoppe 300 px sidelengs
    //Å Gjøre Bedre måte å finne ut dette på
    //Brukes pytagoras a^2 = b^2 + c^2 for å ikke ta den nye blokken for langt til siden
  var maxToSide = Math.sqrt(300*300-235*235);
  var xToSide = Math.floor(Math.random()*maxToSide) + 50;
  var plussOrMinus = Math.floor(Math.random()*2);
  if(plussOrMinus == 1){
    xToSide = -xToSide;
  }
  var blockXPos = lastBlock.x + xToSide;
  //Første blokken har x = 0 så må rette det opp sånn
  if(myObstacles.length == 1){
    blockXPos = window.innerWidth/2 + xToSide;
  }
//Å gjøre ikke gå for langt ut på sidene utenfor bildet

  if(start){
    // -10 Gjør slik den nye blokken ikke blir lagd oppå den gamle
    var blockYPos = lastBlock.y - 10 - Math.floor(Math.random() * 150);
  }
  //Å Gjøre bedre måte å gjøre det på
  else {
    var blockYPos = lastBlock.y - 10 - Math.floor(Math.random() * 100);
  }
  //alert(blockYPos);
  pos = [blockXPos, blockYPos];
  return pos;
}

//Brukes til debugging
function printMousePos(event) {
  alert("clientX: " + event.clientX +
    " - clientY: " + event.clientY);
}

document.addEventListener("click", printMousePos);

</script>
<br>
</body>
</html>
