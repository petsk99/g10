<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>

body {
  margin: 0;
}

canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
/* Fjerner muligheten til å scolle på siden så canvasen dekker hele */
html, body {margin: 0; height: 100%; overflow: hidden}
</style>
</head>
<body onload="startGame()">
<script>

/*
Ting å fikse:
Score når han går opp
Starte med tilfeldig antall blokker
Ikke lage ny blokk hvert 1,5 sek, men når han går opp
Lage algoritme slik at det alltid skal være mulig å lande på en blokk






*/

//Spilleren
var myGamePiece;
//Blokkene den lander på
var myObstacles = [];
//Scoren
var myScore;

function startGame() {
    //Lager figuren og plasserer han i midten lavt nede
    myGamePiece = new component(30, 30, "black", window.innerWidth/2-15, window.innerHeight-280);
    //Start blokken som han starter oppå
    //Å Gjøre endre størrelse utifra skjermstørrelse
    myObstacles.push(new component(100, 10, "green", window.innerWidth/2-50, window.innerHeight-50));


    //For å teste å gå oppover
    myObstacles.push(new component(100, 10, "green", window.innerWidth/2-150, window.innerHeight-170));

    //Setter gravitasjonen i spiller med hvor for han "Går ned"
    myGamePiece.gravity = 0.1;
    //Viser scoren
    myScore = new component("30px", "Consolas", "black", 280, 40, "text");
    //Starter spiller
    myGameArea.start();
}
//Er en object
var myGameArea = {
    //Lager hvis spillet skjer
    canvas : document.createElement("canvas"),

    start : function() {
      //Å Gjøre Få den til å oppdatere canvas størrelsen når man endrer på skjerm størrelsen
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        //Ser hvilke knapper som blir tastet
        window.addEventListener('keydown', function (e) {
            myGameArea.key = e.keyCode;
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.key = false;
        })
        },

    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type) {
    this.type = type;
    this.score = 0;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
    this.gravity = 0;
    this.gravitySpeed = 0;
    this.onBlock = 0;
    this.update = function() {
        ctx = myGameArea.context;
        if (this.type == "text") {
            ctx.font = this.width + " " + this.height;
            ctx.fillStyle = color;
            ctx.fillText(this.text, this.x, this.y);
        } else {
            ctx.fillStyle = color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    this.newPos = function() {
        this.gravitySpeed += this.gravity;
          //Får hvilke tast det er fra https://keycode.info/
        //Å gjøre: Få farten til å være relativ til størrelsen på skjermen

        if (myGameArea.key && myGameArea.key == 37) {this.speedX = -7; } /* Bevger seg til VENSTRE */
        else if (myGameArea.key && myGameArea.key == 39) {this.speedX = 7; } /* Beveger seg til HØYRE */
        else {this.speedX = 0;} /* Hvis ingen av tastene blir trykt står den stille */
        this.x += this.speedX;
        this.y += this.speedY + this.gravitySpeed;
        this.hitBottom();
    }
    //Når den treffer bakken
    this.hitBottom = function() {
        var rockbottom = myGameArea.canvas.height - this.height;
        if (this.y > rockbottom) {
            //De traff bunnen så de har tapt
            this.y = rockbottom;
            this.speedY = 0;
            this.speedX = 0;
            this.gravitySpeed = 0;
        }
    }
    this.crashWith = function(otherobj) {
        var myleft = this.x;
        var myright = this.x + (this.width);
        var mytop = this.y;
        var mybottom = this.y + (this.height);
        var otherleft = otherobj.x;
        var otherright = otherobj.x + (otherobj.width);
        var othertop = otherobj.y;
        var otherbottom = otherobj.y + (otherobj.height);
        var crash = true;
        if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
            crash = false;
        }
        return crash;
    }
}

function updateGameArea() {
    var x, y, height, gap, minWidth, maxWidth;
    for (i = 0; i < myObstacles.length; i += 1) {
        //Ser om spilleren har krasjet i objektet
        if (myGamePiece.crashWith(myObstacles[i])) {
          //Gjør slik at figuren ikke "flyr" opp, men må lande på platformen først. Finnes det en bedre måte?
          if(myGamePiece.gravitySpeed >= 4.5){
            //Bestemmer hvor høyt den hopper
            myGamePiece.speedY = -7;
            //Gjør slik at den alltid hopper like høyt, ikke lavere hvis den har vært kortere tid i luften
            myGamePiece.gravitySpeed = 0;

            //Ser om blokken den akkuratt landet på er nyere enn den forrige
            //er den det må vi flytte alle blokkene ned
            if(myGamePiece.onBlock < i){
              //alert("ny blokk");
              var heightGap = myObstacles[myGamePiece.onBlock].y - myObstacles[i].y;
              //Flytter alle blokkene ned med høydeforskjellen mellom gamle og nye blokken
              for(blokk of myObstacles){
                blokk.y += heightGap;
                //Skrur ned farten hans så han ikke flyr opp når alle andre beveger seg ned Finnes det en bedre måte?
                myGamePiece.speedY += 0.5;
              }

              myGamePiece.onBlock = i;
            }
          }
        }
    }
    myGameArea.clear();
    myGameArea.frameNo += 1;
    //Å gjøre kommer færre jo lenger du har kommet (Bruke score?)
    //Å Gjøre må skje når de når en ny platform / når skjermen går oppover
    //Hvor ofte det blir lagd en platform
    if (myGameArea.frameNo == 1 || everyinterval(150)) {
        //Å Gjøre skal være 0 også gå nedover når man hopper
        y = 20;
        x = Math.floor(Math.random()*myGameArea.canvas.width);
        minWidth = 50;
        maxWidth = 150;
        width = Math.floor(Math.random()*(maxWidth-minWidth+1)+minWidth);
        /*minGap = 50;
        maxGap = 200;
        gap = Math.floor(Math.random()*(maxGap-minGap+1)+minGap);*/
        //Lager de grønne tingene
        myObstacles.push(new component(width, 10, "green", x, y));
        //myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
    }
    for (i = 0; i < myObstacles.length; i += 1) {
        //Flytter objektet
        //myObstacles[i].y += 1;
        myObstacles[i].update();
    }
    myScore.text="SCORE: " + myGameArea.frameNo;
    myScore.update();
    myGamePiece.newPos();
    myGamePiece.update();
}

function everyinterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}

</script>
<br>
</body>
</html>
